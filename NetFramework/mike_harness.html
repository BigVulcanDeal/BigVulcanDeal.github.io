<!DOCTYPE HTML>
<!-- 
This file is a test harness for quickly testing various classes that are part of the Biorealize network architecture
-->
<html>
    <head>
		<title>Biorealize Net Architecture Test Harness</title>
		<script src="http://gojs.net/latest/release/go.js"></script>
		<script>
			function require(name){
				// stub out "require"
				// the following <script/> tags load the dependencies in the correct order
			}
		</script>		
		<script src="source/utilityFunctions.js"></script>		
		<script src="source/S88_classes.js"></script>
		<script src="source/S88_Builder.js"></script>
<script>
	// Put little utility functions here
	
	var cough_syrup_xml_example = "https://bigvulcandeal.github.io/batchml/examples/cough%20syrup%20pmw.xml"
	
	function getCoughSyrupDemoAsBatchInformation(){
		// read in a recipe file ...
		var xmlhttp = new XMLHttpRequest(); 
		xmlhttp.open("GET",cough_syrup_xml_example,false);
		xmlhttp.send(""); 
		var recipeXML = xmlhttp.responseText;
		
		// read into a DOMDocument
		var parser = new DOMParser();
		
		var xml = parser.parseFromString(recipeXML, "application/xml");	 
		
		// Make a BatchInformation object
		// and then load it from the XML
		var BatchInformation = new BatchInformationType();
		BatchInformation.parseBatchML(xml.documentElement);	
		
		return BatchInformation;
	}
</script>		
<script>

// create a new recipe builder object
/*
TODO:
implement While(condition, ...)
implement DoUntil(condition, ...)
Q: How to implement "inline" logic within recipe
Q: How to implement "tag collect" stuff

*/
    function generateBatchInformationUsingRecipeBuilder(){
		// load a RecipeBuilder instance from one of the canned RecipeBuilder examples below
		var testRecipeBuilder = generate_GFP_E_coli_example_protocol(); 
		
		// create a BatchInformation object
		// and load the constructed recipe into it
		var BatchInformation = new BatchInformationType();
		BatchInformation.MasterRecipe_col.push(testRecipeBuilder.RecipeElement);
		return BatchInformation;
	}
	
	function generate_IBD_Organism_culture_protocol(){
		var IBD_Organism_culture_protocol_RecipeBuilder = new RecipeBuilder("IBD culture protocol",
			// create recipe procedure w/ name "Main Procedure".
			RecipeProcedure( "Procedure", 
			/* Declare parameters for trial */
				// Set culture temp to match typical canine core temp
				ProcessParameter("Culture_Temp", "float", 39.0), 
				// GUID for experiment, used as key to retrieve results for this run.  Filled in by batch manager
				ProcessParameter("Batch_ID", "ID", "00000000-0000-0000-0000-000000000000"),
				// Name of Input vessel that holds material for this trial.
				// Filled in by batch manager, and used for selecting the input vessel
				// There is normally a 1:1 correspondence between the input vessel and the Batch ID 
				// since the Batch Manager normally uses the code on the input vessel as the Batch ID
				ProcessParameter("Input_Unit", "string", ""),
			/* Ensure that critical process parameters are set */
				Transition("Wait_For_Params",
					Condition("Procedure.Batch_ID != '00000000-0000-0000-0000-000000000000' && Input_Unit != ''") ),
			/* Declare logical structure of Experiment Recipe */
				// Create Unit to represent Input Carousel
				UnitProcedure("Input_Carousel"
				// to do
				),
				// Create Unit Procedure to represent Input Vessel
				UnitProcedure("Culture_Input"
				  // to do
				)
			)
		);
	}
	
	function generate_GFP_E_coli_example_protocol(){
		var GFP_E_coli_example_protocol_RecipeBuilder = new RecipeBuilder("GFP E coli example protocol",
			RecipeProcedure( "Main Procedure", // create a recipe procedure.  Can be referenced by the default name "Procedure"
				ProcessParameter("Heatshock Target Temp", "float", 42.0), // target temp for heatbath.  Add units and maybe dead-band?
				ProcessParameter("Heatshock Hot Duration", "timePeriod", 90000),  // duration of hot bath, in milliseconds (so 90 seconds)
				ProcessParameter("Ice Bath Target Temp", "float", 4.0), // target temp for ice bath.  Add units and maybe dead-band?		
				//
				UnitProcedure("Manual Heatshock", // Create UnitProcedure named "Manual Heatshock"
					Description("Routine to semi-automate the workflow of heat-shock transformation of bacteria")
				),
				// Declare the Input, Incubation, UV_VIS and Output Unit Procedures as parallel operations,
				// since Input, UV_VIS and Output need to run concurrently with the Incubation Unit Procedure
				Parallel( 
					UnitProcedure("Input", // Create UnitProcedure named "Input" to manage input carousel
						Description("Logic that manages the Input carousel, including transfer to culture unit")
					),
					UnitProcedure("Incubation", // Create UnitProcedure named "Incubation" to manage incubation unit
						Description("Logic that manages culture of organism, including transfers from Input, monitoring of UV_VIS measurements")
					),
					UnitProcedure("UV_VIS", // Create UnitProcedure named "UV_VIS" to manage coordination between incubation unit and spectrometer
						Description("Routine to manage operation of the UV-VIS spectrometer")
					),
					UnitProcedure("Output", // Create UnitProcedure named "Output" to manage output carousel
						Description("Routine to manage operation of Output carousel")
					)				
				)
			)
		);
		return GFP_E_coli_example_protocol_RecipeBuilder;
	}
</script>
<script >
	function testTypedArray(){
		debugger;
		// do a little testing with the TypedArray class
		var test = new TypedArray(BatchListType,3);
		var testx = test.add();
		var newBatchListType = new BatchListType();
		var newControlRecipeType = new ControlRecipeType();
		test.push(newBatchListType);
		alert(test.length);
	}

</script>
<script>			
	function testInstantiations(){
		debugger;		
		// instantiate one of each type to ensure that the constructor logic is error free
		var test_AnyType = new AnyType();
		var test_ApprovalHistoryType = new ApprovalHistoryType();
		var test_BatchListType = new BatchListType();
		var test_ControlRecipeType = new ControlRecipeType();
		var test_EnumerationType = new EnumerationType();
		var test_EnumerationSetType = new EnumerationSetType();
		var test_EquipmentProceduralElementType = new EquipmentProceduralElementType();
		var test_EquipmentProceduralElementClassType = new EquipmentProceduralElementClassType();
		var test_EquipmentElementType = new EquipmentElementType();
		var test_BatchInformationType = new BatchInformationType();
		var test_BatchListEntryType = new BatchListEntryType();
		var test_BatchSizeType = new BatchSizeType();
		var test_ClassInstanceAssociationType = new ClassInstanceAssociationType();
		var test_ConstraintType = new ConstraintType();
		var test_EquipmentConnectionType = new EquipmentConnectionType();
		var test_ValueType = new ValueType();
		var test_EquipmentIDType = new EquipmentIDType();
		var test_EquipmentRequirementType = new EquipmentRequirementType();
		var test_FormulaType = new FormulaType();
		var test_FromIDType = new FromIDType();
		var test_HeaderType = new HeaderType();
		var test_IndividualApprovalType = new IndividualApprovalType();
		var test_LinkType = new LinkType();
		var test_ListHeaderType = new ListHeaderType();
		var test_MasterRecipeType = new MasterRecipeType();
		var test_ModificationLogType = new ModificationLogType();
		var test_OtherInformationType = new OtherInformationType();
		var test_ParameterType = new ParameterType();
		var test_ProcedureLogicType = new ProcedureLogicType();
		var test_PropertyType = new PropertyType();
		var test_RecipeBuildingBlockType = new RecipeBuildingBlockType();
		var test_RecipeElementType = new RecipeElementType();
		var test_StepType = new StepType();
		var test_ToIDType = new ToIDType();
		var test_TransitionType = new TransitionType();
		var test_TransitionType = new TransitionType();
	}
</script>
<script>
	function testEnumerationType(){
		debugger;
		// play with enumeration methods a bit ...
		var testBatchListEntryTypeType = new BatchListEntryTypeType();
		testBatchListEntryTypeType.key = "Phase";
		console.log(testBatchListEntryTypeType.value);
		testBatchListEntryTypeType.value = 3;
		console.log(testBatchListEntryTypeType.key);
		var y = {"key" : "Campaign"};
		testBatchListEntryTypeType.parseValTree(y);
		console.log(testBatchListEntryTypeType.toJSON());
	}
</script>
<script>
	function testCreateMasterRecipe(){
		debugger;
		// make a simple master recipe object
		var MasterRecipe = new MasterRecipeType();
		MasterRecipe.ID = "testMasterRecipe";
		MasterRecipe.Version = "some version";
		MasterRecipe.VersionDate = Date.now();
		MasterRecipe.Description_col.push("some new description");
		// MasterRecipe.Header
			var ModificationLog = MasterRecipe.Header.ModificationLog_col.add();
				ModificationLog.ModifiedDate = Date.now();;
				ModificationLog.Description_col.push("a new description");
				ModificationLog.Author = "mike hogan";
				// ModificationLog.Any_col = new TypedArray(AnyType); // array of AnyType
			var ApprovalHistory = MasterRecipe.Header.ApprovalHistory_col.add();
				ApprovalHistory.FinalApprovalDate = Date.now();
				ApprovalHistory.Version = "some random version";
				ApprovalHistory.Description_col.push("some new description");
				var IndividualApproval = ApprovalHistory.IndividualApproval_col.add();
					IndividualApproval.ApprovedBy = "mike hogan, again";
					IndividualApproval.ApprovalDate = Date.now();
					IndividualApproval.Description_col.push("some description");
					//IndividualApproval.Any_col = new TypedArray(AnyType); // array of AnyType		
				// ApprovalHistory.Any_col = new TypedArray(AnyType); // array of AnyType
			MasterRecipe.Header.EffectiveDate = Date.now();
			MasterRecipe.Header.ExpirationDate = Date.now();
			MasterRecipe.Header.ProductID = "KRAGL";
			MasterRecipe.Header.ProductName = "Krazy glue";
			// MasterRecipe.Header.BatchSize
				MasterRecipe.Header.BatchSize.Nominal = 5;
				MasterRecipe.Header.BatchSize.Min = 0;
				MasterRecipe.Header.BatchSize.Max = 10;
				MasterRecipe.Header.BatchSize.ScaleReference = 1;
				MasterRecipe.Header.BatchSize.ScaledSize = 5;
				MasterRecipe.Header.BatchSize.UnitOfMeasure = "smoots";
				// MasterRecipe.Header.BatchSize.Any_col = new TypedArray(AnyType); // array of AnyType
			MasterRecipe.Header.ActualProductProduced_col.push("actual krazy glue");
			MasterRecipe.Header.Status.otherValue = "status value makes no sense in this context, wtf?";
			//MasterRecipe.Header.Any_col = new TypedArray(AnyType); // array of AnyType
		var EquipmentRequirement = MasterRecipe.EquipmentRequirement_col.add();
			EquipmentRequirement.ID = "some piece of equipment";
			var Constraint = EquipmentRequirement.Constraint_col.add();
				Constraint.ID = "some ID";
				Constraint.Condition = "some condition";
				// Constraint.Any_col = new TypedArray(AnyType); // array of AnyType
			EquipmentRequirement.Description = "some description";
			// EquipmentRequirement.Any_col = TypedArray(AnyType); // array of AnyType
		var Formula = MasterRecipe.Formula = new FormulaType();
			var Parameter = Formula.Parameter_col.add() // = new ParameterType_Array(); // array of ParameterType
				Parameter.ID = "some parameter id";
				Parameter.Description = "some parameter description";
				Parameter.ParameterType.value = ParameterType1Type.ProcessParameter;
				Parameter.ParameterSubType_col.push("some ParameterSubType");
				var Parameter_Value = Parameter.Value_col.add();
					Parameter_Value.ValueString_col.push("some ValueString");
					Parameter_Value.DataInterpretation = new DataInterpretationType();
					Parameter_Value.DataType = new DataTypeType();
					Parameter_Value.UnitOfMeasure = "";
					Parameter_Value.EnumerationSetID_col = new Array(); // array of string
					Parameter_Value.Any_col = new TypedArray(AnyType);		
				Parameter.Scaled = "";
				Parameter.ScaleReference = 0;
				Parameter.Parameter_col = new TypedArray(ParameterType); // array of ParameterType
				// Parameter.Any_col = new TypedArray(AnyType); // array of AnyType	
			// Formula.Any_col = new TypedArray(AnyType); // array of AnyType

		// MasterRecipe.ProcedureLogic
			MasterRecipe.ProcedureLogic.Link_col.add();
			MasterRecipe.ProcedureLogic.Step_col.add();
			MasterRecipe.ProcedureLogic.Transition_col.add();
			// this.Any_col = new TypedArray(AnyType);
			
		MasterRecipe.RecipeElement_col = new TypedArray(RecipeElementType); // array of RecipeElementType
		MasterRecipe.OtherInformation_col = new TypedArray(OtherInformationType); // array of OtherInformationType
		MasterRecipe.Any_col = new TypedArray(AnyType); // array of AnyType

		// see if we can generate an identical MasterREcipe object from the JSON of a first one
		MasterRecipe2 = new MasterRecipeType();
		MasterRecipe2.parseJSON(JSON.stringify(MasterRecipe));
	}
</script>
<script>
	function testparseBatchML(){
		debugger;
	
		// read in a recipe file ...
		var xmlhttp = new XMLHttpRequest(); 
		xmlhttp.open("GET",cough_syrup_xml_example,false); 
		xmlhttp.send(""); 
		var recipeXML = xmlhttp.responseText;

		var parser = new DOMParser();
		var xml = parser.parseFromString(recipeXML, "application/xml");
		var BatchInformation = new BatchInformationType();
		BatchInformation.parseBatchML(xml.documentElement);

		// export the data as JSON
		var BatchInformationJSON = BatchInformation.toJSON();
		
		// make a new object, and "clone" it from the original by ingesting the JSON
		var newBatchInformation = new BatchInformationType();
		newBatchInformation.parseJSON(BatchInformationJSON);
		
		// export the JSON for scrutiny ...
		console.log(BatchInformationJSON);
	}
</script>
<script>
	function testControlRecipeFromMasterRecipe(){
		debugger;
	
		// read in a recipe file ...
		var xmlhttp = new XMLHttpRequest(); 
		xmlhttp.open("GET",cough_syrup_xml_example,false); 
		xmlhttp.send(""); 
		var recipeXML = xmlhttp.responseText;
		
		// read into a DOMDocument
		var parser = new DOMParser();
		var xml = parser.parseFromString(recipeXML, "application/xml");	 
		
		// Make a BatchInformation object
		// and then load it from the XML
		var BatchInformation = new BatchInformationType();
		BatchInformation.parseBatchML(xml.documentElement);

		// Get a MasterRecipe object from the BatchInformation object
		var MasterRecipe = BatchInformation.MasterRecipe_col[0];
		
		// Make a new ControlRecipe object
		var ControlRecipe = new ControlRecipeType();
		
		// Load the ControlRecipe from the MasterRecipe
		ControlRecipe.parseValTree(MasterRecipe);
		
		// export the JSON for scrutiny ...
		console.log(ControlRecipe.toJSON());
	}
</script>
<script>
	function testGenerateBatchML(){
		debugger;
	
		// read in a recipe file ...
		var xmlhttp = new XMLHttpRequest(); 
		xmlhttp.open("GET",cough_syrup_xml_example,false); 
		xmlhttp.send(""); 
		var recipeXML = xmlhttp.responseText;
		
		// read into a DOMDocument
		var parser = new DOMParser();
		var xml = parser.parseFromString(recipeXML, "application/xml");	 
		
		// Make a BatchInformation object
		// and then load it from the XML
		var BatchInformation = new BatchInformationType();
		BatchInformation.parseBatchML(xml.documentElement);

		// Create a new XML document
		var xmlOut = parser.parseFromString("<BatchInformation/>", "application/xml");	
		BatchInformation.toBatchML(xmlOut.documentElement);
	}
</script>
<script>
  function testTreeView() {
  
	debugger;
	document.getElementById("treeDiagramDiv").style.display = "block";
	
//	var BatchInformation = getCoughSyrupDemoAsBatchInformation();
	var BatchInformation = generateSimpleRecipe();
	
    var $ = go.GraphObject.make;  // for conciseness in defining templates

    myDiagram =
      $(go.Diagram, "treeDiagramDiv",
        {
          allowMove: false,
          allowCopy: false,
          allowDelete: false,
          allowHorizontalScroll: false,
          layout:
            $(go.TreeLayout,
              {
                alignment: go.TreeLayout.AlignmentStart,
                angle: 0,
                compaction: go.TreeLayout.CompactionNone,
                layerSpacing: 16,
                layerSpacingParentOverlap: 1,
                nodeIndent: 2,
                nodeIndentPastParent: 0.88,
                nodeSpacing: 0,
                setsPortSpot: false,
                setsChildPortSpot: false
              })
      });

    myDiagram.nodeTemplate =
      $(go.Node,
        { // no Adornment: instead change panel background color by binding to Node.isSelected
          selectionAdorned: false,
          // a custom function to allow expanding/collapsing on double-click
          // this uses similar logic to a TreeExpanderButton
          doubleClick: function(e, node) {
            var cmd = myDiagram.commandHandler;
            if (node.isTreeExpanded) {
              if (!cmd.canCollapseTree(node)) return;
            } else {
              if (!cmd.canExpandTree(node)) return;
            }
            e.handled = true;
            if (node.isTreeExpanded) {
              cmd.collapseTree(node);
            } else {
              cmd.expandTree(node);
            }
          }
        },
        $("TreeExpanderButton",
          {
            width: 14,
            "ButtonBorder.fill": "whitesmoke",
            "ButtonBorder.stroke": null,
            "_buttonFillOver": "rgba(0,128,255,0.25)",
            "_buttonStrokeOver": null
          }),
        $(go.Panel, "Horizontal",
          { position: new go.Point(16, 0) },
          new go.Binding("background", "isSelected", function (s) { return (s ? "lightblue" : "white"); }).ofObject(),
          $(go.Picture,
            {
              width: 18, height: 18,
              margin: new go.Margin(0, 4, 0, 0),
              imageStretch: go.GraphObject.Uniform
            },
            // bind the picture source on two properties of the Node
            // to display open folder, closed folder, or document
            new go.Binding("source", "isTreeExpanded", imageConverter).ofObject(),
            new go.Binding("source", "isTreeLeaf", imageConverter).ofObject()),
          $(go.TextBlock,
            { font: '9pt Verdana, sans-serif' },
            new go.Binding("text", "text", function(s) { return  s; })
)
        )  // end Horizontal Panel
      );  // end Node

    // without lines
    myDiagram.linkTemplate = $(go.Link);

    // // with lines
    // myDiagram.linkTemplate =
    //   $(go.Link,
    //     { selectable: false,
    //       routing: go.Link.Orthogonal,
    //       fromEndSegmentLength: 4,
    //       toEndSegmentLength: 4,
    //       fromSpot: new go.Spot(0.001, 1, 7, 0),
    //       toSpot: go.Spot.Left },
    //     $(go.Shape,
    //       { stroke: 'gray', strokeDashArray: [1,2] }));

    // create a random tree
    var nodeDataArray = [{ key: 0 }];
	var count = 0;
    makeTree(BatchInformation, nodeDataArray, nodeDataArray[0], count, "BatchInformation");
 
    myDiagram.model = new go.TreeModel(nodeDataArray);
  }

	/** 
	* makeTree traverses the S88 object hierarchy and builds up a tree representation
	*/
	function makeTree(S88Object, nodeDataArray, parentdata, count, name) {
		var typeName = S88Object.constructor.name;
		
		// append this object to the tree
		count++;
		var thisData = { key: count, parent: parentdata.key, text: name };
		nodeDataArray.push(thisData);		
		
		switch (typeName) {
			
			// if the value corresponds to an atomic type,
			// then use casting to ensure (as best we can)
			// the the value is ingested as the proper type.
			case "String":
			case "Number":
			case "Date":
					thisData.text += ":" + S88Object.toString();
				break;								
			case "Array":
				var elementName = name.substr(0,name.length-4);
				thisData.text = elementName + "[]";
				for(var i = 0; i < S88Object.length; i ++){
					count++;
					var childData = { key: count, parent: thisData.key, text: elementName + "[" + i + "]:" + S88Object[i].toString()};
					nodeDataArray.push(childData);			
				}
				break;
			default:
				if (S88Object.baseClass() == "S88Base"){
					// get the type information for this object
					// and append each of its children to the tree
					var typeInfoElements = S88Object.typeInfo._elements;
					for (var i = 0; i < typeInfoElements.length; i++){
						var key = typeInfoElements[i].name;
						var childObject = S88Object[key];
						count = makeTree(childObject, nodeDataArray, thisData, count, key);
					}
				}
				else if(S88Object.baseClass() == "TypedArray"){
					var elementName = name.substr(0,name.length-4);
					thisData.text = elementName + "[]";
					for (var i = 0; i < S88Object.length; i++){
						count = makeTree(S88Object[i], nodeDataArray, thisData, count,  elementName + "[" + i + "]");
					}					
				}
				else if(S88Object.baseClass() == "EnumClass"){
					thisData.text += ":" + S88Object.key;
					if(S88Object.key == "Other"){
						thisData.text += "=" + S88Object.OtherValue;
					}
				}				
				else{
					debugger;
				}
		}
		return count;
	}

  // takes a property change on either isTreeLeaf or isTreeExpanded and selects the correct image to use
  function imageConverter(prop, picture) {
    var node = picture.part;
    if (node.isTreeLeaf) {
      return "images/document.png";
    } else {
      if (node.isTreeExpanded) {
        return "images/openFolder.png";
      } else {
        return "images/closedFolder.png";
      }
    }
  }
</script>

<script>
  function testSFCView() {
    
		document.getElementById("SFC_Div").style.display = "block";
		
	var $ = go.GraphObject.make;
	

    myDiagram =
      $(go.Diagram, "SFC_Div", // must be the ID or reference to an HTML DIV
        {
          // start everything in the middle of the viewport
          initialContentAlignment: go.Spot.Center,
          layout: $(go.LayeredDigraphLayout, { direction: 90, layerSpacing: 10, setsPortSpots: false }),
          "undoManager.isEnabled": true  // enable undo & redo
        });

    // when the document is modified, add a "*" to the title and enable the "Save" button
    myDiagram.addDiagramListener("Modified", function(e) {
      var button = document.getElementById("SaveButton");
      if (button) button.disabled = !myDiagram.isModified;
      var idx = document.title.indexOf("*");
      if (myDiagram.isModified) {
        if (idx < 0) document.title += "*";
      } else {
        if (idx >= 0) document.title = document.title.substr(0, idx);
      }
    });

    // define the step Node template
    myDiagram.nodeTemplateMap.add("step",
      $(go.Node, "Spot",
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "Rectangle",
          {
            fill: "whitesmoke",
            stroke: "gray",
            strokeWidth: 2,
            desiredSize: new go.Size(160, 60),
            portId: "",  // so that links connect to the Shape, not to the whole Node
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide,
            alignment: go.Spot.Center
          }),
        $(go.TextBlock,
          {
            font: "bold 16px sans-serif",
            alignment: go.Spot.Center,
            wrap: go.TextBlock.WrapFit,
            editable: true
          },
          new go.Binding("text", "text").makeTwoWay())
      ));

    // define the transition Node template.
    myDiagram.nodeTemplateMap.add("transition",
      $(go.Node, "Horizontal",
        { locationSpot: go.Spot.Center, locationObjectName: "BAR" },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "Rectangle",
          {
            name: "BAR",
            fill: "black",
            stroke: null,
            desiredSize: new go.Size(60, 8),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          }),
        $(go.TextBlock,
          { editable: true, margin: 3 },
          new go.Binding("text", "text").makeTwoWay())
      ));

    // define the parallel Node template.
    myDiagram.nodeTemplateMap.add("parallel",
      $(go.Node,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "Rectangle",
          {
            fill: "whitesmoke",
            stroke: "black",
            fromSpot: go.Spot.BottomCenter,
            toSpot: go.Spot.TopCenter,
            desiredSize: new go.Size(200, 6),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          })
      ));

    // define the Link template
    myDiagram.linkTemplate =
      $(go.Link,
        { routing: go.Link.Orthogonal },
        $(go.Shape,
          { stroke: "black", strokeWidth: 2 })
      );

    // Load a 
    makeSFC();
  }

	function makeSFC(){
		// initialize a BatchInformation object using "cough syrup pmw.xml"
		var BatchInformation = getCoughSyrupDemoAsBatchInformation();
		
		// get the procedure logic for the "Make Suspension" Unit Procedure
		var ProcedureLogic = BatchInformation.MasterRecipe_col[0].RecipeElement_col[2].RecipeElement_col[2].ProcedureLogic;
		
		// get the RecipeElements for the "Make Suspension" Unit Procedure
		// then call the genKey("ID") method, so that we can retrieve RecipeElements by name
		var RecipeElements = BatchInformation.MasterRecipe_col[0].RecipeElement_col[2].RecipeElement_col[2].RecipeElement_col;
		RecipeElements.genKeys("ID");
		
		// create an empty structure to represent the chart.
		// we will build up a representation by iterating over the ProcedureLogic
		var SFC_struct = { "nodeDataArray": [], "linkDataArray": [] };
		
		// add Steps to nodeDataArray
		for(var i = 0; i < ProcedureLogic.Step_col.length; i++){
			var step = ProcedureLogic.Step_col[i];
			var RecipeElementID = step.RecipeElementID
			var RecipeElement = RecipeElements.getByKey("ID",RecipeElementID);
			var Description = RecipeElement.Description_col[0];
			var RecipeElementType = RecipeElement.RecipeElementType.key;
			if ((RecipeElementType == "Begin") || (RecipeElementType == "End")){
				Description = RecipeElementType;
			}
			var node = {"key":step.ID, "category":"step", "text":Description };
			SFC_struct.nodeDataArray.push(node);
		}
		
		// add Transitions to nodeDataArray		
		for(var i = 0; i < ProcedureLogic.Transition_col.length; i++){
			var trans = ProcedureLogic.Transition_col[i];
			var node = {"key":trans.ID, "category":"transition", "text":trans.ID + ":" + trans.Condition };
			SFC_struct.nodeDataArray.push(node);
		}	
		
		// add parallel branches to nodeDataArray
		for(var i = 0; i < ProcedureLogic.Link_col.length; i++){
			var link = ProcedureLogic.Link_col[i];
			if( link.LinkType.key.startsWith("Parallel")){
				var node = {"key":link.ID, "category":"parallel"};
				SFC_struct.nodeDataArray.push(node);
			}
		}		

		// add links to the chart ...
		for(var i = 0; i < ProcedureLogic.Link_col.length; i++){
			var link = ProcedureLogic.Link_col[i];
			if( !link.LinkType.key.startsWith("Parallel")){
				var link_ = {"from":link.FromID_col[0].FromIDValue, "to":link.ToID_col[0].ToIDValue};
				SFC_struct.linkDataArray.push(link_);
			}
		}		
		
		// send the JSON to the model
		myDiagram.model = go.Model.fromJson(JSON.stringify(SFC_struct));
	}
	
</script>

  <script >
  
	var BatchInformation;
	
    function testHierarchicalGrouping() {
		// make the DIV visible ..
		document.getElementById("testHierarchicalGroupingDiv").style.display = "block";
	
	  // make BatchInformation object that has the Cough Syrup demo in it 
	  BatchInformation = getCoughSyrupDemoAsBatchInformation(); 
	  
	  

      var $ = go.GraphObject.make;  // for conciseness in defining templates

	  // To simplify this code we define a function for creating a context menu button:
    function makeButton(text, action, visiblePredicate) {
      return $("ContextMenuButton",
               $(go.TextBlock, text),
               { click: action },
               // don't bother with binding GraphObject.visible if there's no predicate
               visiblePredicate ? new go.Binding("visible", "", function(o, e) { return o.diagram ? visiblePredicate(o, e) : false; }).ofObject() : {});
    }	  
    var nodeMenu =  // context menu for each Node
      $(go.Adornment, "Vertical",
        makeButton("Copy",
                   function(e, obj) { alert(obj.category);}),
        makeButton("Delete",
                   function(e, obj) { e.diagram.commandHandler.deleteSelection(); }),
        $(go.Shape, "LineH", { strokeWidth: 2, height: 1, stretch: go.GraphObject.Horizontal }),
        makeButton("Add top port",
                   function (e, obj) { addPort("top"); }),
        makeButton("Add left port",
                   function (e, obj) { addPort("left"); }),
        makeButton("Add right port",
                   function (e, obj) { addPort("right"); }),
        makeButton("Add bottom port",
                   function (e, obj) { addPort("bottom"); })
      );	  

      groupingDiagram  =
        $(go.Diagram, "testHierarchicalGroupingDiv",  // Diagram refers to its DIV HTML element by id
          {
            // start everything in the middle of the viewport
            initialContentAlignment: go.Spot.Center,
            layout: $(go.TreeLayout,  // the layout for the entire diagram
                      {
                        angle: 90,
                        arrangement: go.TreeLayout.ArrangementHorizontal,
                        isRealtime: false
                      })
          });

/*
      groupingDiagram.nodeTemplate =
        $(go.Node, "Auto",
          $(go.Shape, "Rectangle",
            { stroke: null, strokeWidth: 0 },
            new go.Binding("fill", "0xFFFFFF")
			),
          $(go.TextBlock,
            { margin: 7, font: "Bold 14px Sans-Serif" },
            //the text, color, and key are all bound to the same property in the node data
            new go.Binding("text", "label"))
        );
*/		
		groupingDiagram.nodeTemplateMap.add("step",
		  $(go.Node, "Spot",
			{ locationSpot: go.Spot.Center },
			new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
			$(go.Shape, "Rectangle",
			  {
				fill: "whitesmoke",
				stroke: "gray",
				strokeWidth: 2,
				desiredSize: new go.Size(160, 60),
				portId: "",  // so that links connect to the Shape, not to the whole Node
				fromSpot: go.Spot.BottomSide,
				toSpot: go.Spot.TopSide,
				alignment: go.Spot.Center,
				contextMenu: nodeMenu
			  }),
			$(go.TextBlock,
			  {
				font: "bold 8px sans-serif",
				alignment: go.Spot.Center,
				wrap: go.TextBlock.WrapFit,
				editable: true
			  },
			  new go.Binding("text", "label").makeTwoWay())
			  
			  
		  ));	
		  
    // define the transition Node template.
    groupingDiagram.nodeTemplateMap.add("transition",
      $(go.Node, "Horizontal",
        { locationSpot: go.Spot.Center, locationObjectName: "BAR" },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "Rectangle",
          {
            name: "BAR",
            fill: "black",
            stroke: null,
            desiredSize: new go.Size(60, 8),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          }),
        $(go.TextBlock,
          { editable: true, margin: 3 },
          new go.Binding("text", "text").makeTwoWay())
      ));
	  
    // define the parallel Node template.
    groupingDiagram.nodeTemplateMap.add("parallel",
      $(go.Node,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "Rectangle",
          {
            fill: "whitesmoke",
            stroke: "black",
            desiredSize: new go.Size(200, 6),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          })
      ));
	  
    // define the Link template
      groupingDiagram.linkTemplate =
        $(go.Link,
          { routing: go.Link.AvoidsNodes},
          $(go.Shape, { strokeWidth: 2 }),
          $(go.Shape, { toArrow: "Standard" })
        );

      // define the group template
      groupingDiagram.groupTemplate =
        $(go.Group, "Auto",
          { // define the group's internal layout
            layout: $(go.TreeLayout,
                      { angle: 90, arrangement: go.TreeLayout.ArrangementHorizontal, isRealtime: false }),
            // the group begins unexpanded;
            // upon expansion, a Diagram Listener will generate contents for the group
            isSubGraphExpanded: false,
            // when a group is expanded, if it contains no parts, generate a subGraph inside of it
            subGraphExpandedChanged: function(group) {
              if (group.memberParts.count === 0) {
                generateHierarchicalGrouping(group.data);
              }
            }
          },
          $(go.Shape, "Rectangle",
            { fill: null, stroke: "gray", strokeWidth: 2 }),
          $(go.Panel, "Vertical",
            { defaultAlignment: go.Spot.Left, margin: 4 },
            $(go.Panel, "Horizontal",
              { defaultAlignment: go.Spot.Top },
              // the SubGraphExpanderButton is a panel that functions as a button to expand or collapse the subGraph
              $("SubGraphExpanderButton"),
              $(go.TextBlock,
                { font: "Bold 18px Sans-Serif", margin: 4 },
                new go.Binding("text", "label"))
            ),
            // create a placeholder to represent the area where the contents of the group are
            $(go.Placeholder,
              { padding: new go.Margin(0, 10) })
          )  // end Vertical Panel
        );  // end Group

      // generate the initial model
	  var MasterRecipe = BatchInformation.MasterRecipe_col[0];
	  var rootNodeData = { key: name, isGroup: true,  S88Obj: MasterRecipe,label:"Cough Syrup (Master Recipe)"};
	  groupingDiagram.model.addNodeData(rootNodeData);
      generateHierarchicalGrouping(rootNodeData);
    }

    // The generateHierarchicalGrouping function accepts a node that represents a group and renders the sub-graph for that
	// group by parsing the children within the S88 object associated with the group.
	function generateHierarchicalGrouping(group_data) {
		// all modification to the diagram is within this transaction
		groupingDiagram.startTransaction("addGroupContents");
		var addedKeys = [];  // this will contain the keys of all nodes created
		var groupCount = 0;  // the number of groups in the diagram, to determine the numbers in the keys of new groups
		groupingDiagram.nodes.each(function(node) {
			if (node instanceof go.Group) groupCount++;
		});
	  
		// ensure that any subordinate RecipeElements are indexed
		group_data.S88Obj.RecipeElement_col.genKeys("ID");

		// Generate a node for each Step
		for (var i = 0; i < group_data.S88Obj.ProcedureLogic.Step_col.length; i++) {
			var step = group_data.S88Obj.ProcedureLogic.Step_col[i];
			var recipeElement = group_data.S88Obj.RecipeElement_col.getByKey("ID",step.RecipeElementID);
			var isGroup = (recipeElement.RecipeElement_col.length > 0);
			var label = (recipeElement.Description_col[0] == undefined) ? "" : recipeElement.Description_col[0] + " " ;
			label += "(" + recipeElement.RecipeElementType.key + ")";
			groupingDiagram.model.addNodeData({ key: step.ID, isGroup: isGroup, group: group_data.key, category:"step", label: label, S88Obj:recipeElement });
		}

		// Generate a node for each Trans
		for (var i = 0; i < group_data.S88Obj.ProcedureLogic.Transition_col.length; i++) {
			var trans = group_data.S88Obj.ProcedureLogic.Transition_col[i];
			groupingDiagram.model.addNodeData({ key: trans.ID, isGroup: false, group: group_data.key, category:"transition"});
		}
		
		// add parallel branches to nodeDataArray
		for(var i = 0; i < group_data.S88Obj.ProcedureLogic.Link_col.length; i++){
			var link = group_data.S88Obj.ProcedureLogic.Link_col[i];
			if( link.LinkType.key.startsWith("Parallel")){
				groupingDiagram.model.addNodeData({ key: link.ID, isGroup: false, group: group_data.key, category:"parallel"});
			}
		}		
		
		// Add links
		// add parallel branches to nodeDataArray
		for(var i = 0; i < group_data.S88Obj.ProcedureLogic.Link_col.length; i++){
			var link = group_data.S88Obj.ProcedureLogic.Link_col[i];
			if( !link.LinkType.key.startsWith("Parallel")){
				groupingDiagram.model.addLinkData({ from: link.FromID_col[0].FromIDValue, to: link.ToID_col[0].ToIDValue });
			}
		}			

		groupingDiagram.commitTransaction("addGroupContents");
	}
  </script>

 <script >
  
	var BatchInformation;
	
    function testPFCRendering() {
		// make the DIV visible ..
		document.getElementById("testPFCRenderingDiv").style.display = "block";
		    

      var $ = go.GraphObject.make;  // for conciseness in defining templates

	  // To simplify this code we define a function for creating a context menu button:

      PFC_Diagram  =
        $(go.Diagram, "testPFCRenderingDiv",  // Diagram refers to its DIV HTML element by id
          {
            // start everything in the middle of the viewport
            initialContentAlignment: go.Spot.Center,
            layout: $(go.TreeLayout,  // the layout for the entire diagram
                      {
                        angle: 90,
                        arrangement: go.TreeLayout.ArrangementHorizontal,
                        isRealtime: false
                      })
          });

    function nodeStyle() {
      return [
        // The Node.location comes from the "loc" property of the node data,
        // converted by the Point.parse static method.
        // If the Node.location is changed, it updates the "loc" property of the node data,
        // converting back using the Point.stringify static method.
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        {
          // the Node.location is at the center of each node
          locationSpot: go.Spot.Center,
          //isShadowed: true,
          //shadowColor: "#888",
          // handle mouse enter/leave events to show/hide the ports
          mouseEnter: function (e, obj) { showPorts(obj.part, true); },
          mouseLeave: function (e, obj) { showPorts(obj.part, false); }
        }
      ];
    }		  
		  
  // Make all ports on a node visible when the mouse is over the node
  function showPorts(node, show) {
    var diagram = node.diagram;
    if (!diagram || diagram.isReadOnly || !diagram.allowLink) return;
    node.ports.each(function(port) {
        port.stroke = (show ? "black" : null);
      });
  }
  
    // Define a function for creating a "port" that is normally transparent.
    // The "name" is used as the GraphObject.portId, the "spot" is used to control how links connect
    // and where the port is positioned on the node, and the boolean "output" and "input" arguments
    // control whether the user can draw links from or to the port.
    function makePort(name, spot, output, input) {
      // the port is basically just a small circle that has a white stroke when it is made visible
      return $(go.Shape, "Circle",
               {
                  fill: "transparent",
                  stroke: null,  // this is changed to "white" in the showPorts function
                  desiredSize: new go.Size(8, 8),
                  alignment: spot, alignmentFocus: spot,  // align the port on the main Shape
                  portId: name,  // declare this object to be a "port"
                  fromSpot: spot, toSpot: spot,  // declare where links may connect at this port
                  fromLinkable: output, toLinkable: input,  // declare whether the user may draw links to/from here
                  cursor: "pointer"  // show a different cursor to indicate potential link point
               });
    }	
		PFC_Diagram.nodeTemplateMap.add("Phase",
		  $(go.Node, "Spot", nodeStyle(),
			{ locationSpot: go.Spot.Center },
			$(go.Panel, "Auto",
				$(go.Shape, "Rectangle",
				  {
					fill: "whitesmoke",
					stroke: "gray",
					strokeWidth: 2,
					desiredSize: new go.Size(160, 60),
					portId: "",  // so that links connect to the Shape, not to the whole Node
					fromSpot: go.Spot.BottomSide,
					toSpot: go.Spot.TopSide,
					alignment: go.Spot.Center
				  }),
				$(go.TextBlock,
				  {
					font: "bold 8px sans-serif",
					alignment: go.Spot.Center,
					wrap: go.TextBlock.WrapFit,
					editable: true
				  },
				  new go.Binding("text", "label").makeTwoWay())
			),
			makePort("T", go.Spot.Top, false, true),
			makePort("B", go.Spot.Bottom, false, true)				  
		));	

    // define the Begin Node template.
    PFC_Diagram.nodeTemplateMap.add("Begin",
      $(go.Node,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "TriangleDown",
          {
            fill: "whitesmoke",
            stroke: "black",
            desiredSize: new go.Size(60, 52),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          })
      ));

	  PFC_Diagram.nodeTemplateMap.add("End",
      $(go.Node,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "TriangleUp",
          {
            fill: "whitesmoke",
            stroke: "black",
            desiredSize: new go.Size(60, 52),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          })
      ));
		  
    // define the transition Node template.
    PFC_Diagram.nodeTemplateMap.add("transition",
      $(go.Node, "Horizontal",
        { locationSpot: go.Spot.Center, locationObjectName: "BAR" },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "Rectangle",
          {
            name: "BAR",
            fill: "black",
            stroke: null,
            desiredSize: new go.Size(60, 8),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          }),
        $(go.TextBlock,
          { editable: true, margin: 3 },
          new go.Binding("text", "label").makeTwoWay())	  
      ));
	  
    // define the parallel Node template.
    PFC_Diagram.nodeTemplateMap.add("parallel",
      $(go.Node,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
        $(go.Shape, "Rectangle",
          {
            fill: "whitesmoke",
            stroke: "black",
            desiredSize: new go.Size(200, 6),
            portId: "",
            fromSpot: go.Spot.BottomSide,
            toSpot: go.Spot.TopSide
          })
      ));
	  
    // define the Link template
      PFC_Diagram.linkTemplate =
        $(go.Link,
          { routing: go.Link.AvoidsNodes},
          $(go.Shape, { strokeWidth: 2 })
        );

      // define the group template
      PFC_Diagram.groupTemplate =
        $(go.Group, "Auto",
          { // define the group's internal layout
            layout: $(go.TreeLayout,
                      { angle: 90, arrangement: go.TreeLayout.ArrangementHorizontal, isRealtime: false }),
            // the group begins unexpanded;
            // upon expansion, a Diagram Listener will generate contents for the group
            isSubGraphExpanded: false,
            // when a group is expanded, if it contains no parts, generate a subGraph inside of it
            subGraphExpandedChanged: function(group) {
              if (group.memberParts.count === 0) {
                generatePFCGrouping(group.data);
              }
            }
          },
          $(go.Shape, "Rectangle",
            { fill: null, stroke: "gray", strokeWidth: 2 })	,
          $(go.Panel, "Vertical",
            { defaultAlignment: go.Spot.Left, margin: 4 },
            $(go.Panel, "Horizontal",
              { defaultAlignment: go.Spot.Top },
              // the SubGraphExpanderButton is a panel that functions as a button to expand or collapse the subGraph
              $("SubGraphExpanderButton"),
              $(go.TextBlock,
                { font: "Bold 18px Sans-Serif", margin: 4 },
                new go.Binding("text", "label"))
            ),
            // create a placeholder to represent the area where the contents of the group are
            $(go.Placeholder,
              { padding: new go.Margin(0, 10) })
          )  // end Vertical Panel		  
        );  // end Group

	  // make BatchInformation object that has the Cough Syrup demo in it 
	  BatchInformation = getCoughSyrupDemoAsBatchInformation(); 
	  //BatchInformation = generateSimpleBatchInformation();
	  // BatchInformation = generateBatchInformationUsingRecipeBuilder(); 

	  // Get a reference to the MasterRecipe that represents the CoughSyrup recipe
	  var MasterRecipe = BatchInformation.MasterRecipe_col[0];
	  
	  // Create the root node for the graph
	  // mark it as "grouped"
	  // and associate the MasterRecipe object with it.
	  var rootNodeData = { key: name, isGroup: true, S88Obj: MasterRecipe, label:MasterRecipe.Description_col[0] + " (Master Recipe)"};
	  PFC_Diagram.model.addNodeData(rootNodeData);
      generatePFCGrouping(rootNodeData);
    }

    // The generateHierarchicalGrouping function accepts a group node that represents an S88 object
	// and executes logic to render the chart for the S88 objects that are contained within that group.
	function generatePFCGrouping(group_data) {
		// all modification to the diagram is within this transaction
		PFC_Diagram.startTransaction("addGroupContents");
		var addedKeys = [];  // this will contain the keys of all nodes created
		var groupCount = 0;  // the number of groups in the diagram, to determine the numbers in the keys of new groups
		PFC_Diagram.nodes.each(function(node) {
			if (node instanceof go.Group) groupCount++;
		});
	  
		// ensure that any subordinate RecipeElements are indexed
		group_data.S88Obj.RecipeElement_col.genKeys("ID");

		// Generate a node for each Step
		for (var i = 0; i < group_data.S88Obj.ProcedureLogic.Step_col.length; i++) {
			var step = group_data.S88Obj.ProcedureLogic.Step_col[i];
			var recipeElement = group_data.S88Obj.RecipeElement_col.getByKey("ID",step.RecipeElementID);

			var isGroup = (recipeElement.RecipeElement_col.length > 0);
			var label = (recipeElement.Description_col[0] == undefined) ? "" : recipeElement.Description_col[0] + " " ;
			label += "(" + recipeElement.RecipeElementType.key + ")";			
			PFC_Diagram.model.addNodeData({ key: step.ID, isGroup: isGroup, group: group_data.key, category:recipeElement.RecipeElementType.key, label: label, S88Obj:recipeElement });

		}

		// Generate a node for each Trans
		for (var i = 0; i < group_data.S88Obj.ProcedureLogic.Transition_col.length; i++) {
			var trans = group_data.S88Obj.ProcedureLogic.Transition_col[i];
			PFC_Diagram.model.addNodeData({ key: trans.ID, isGroup: false, group: group_data.key, category:"transition"});
		}
		
		// add parallel branches to nodeDataArray
		for(var i = 0; i < group_data.S88Obj.ProcedureLogic.Link_col.length; i++){
			var link = group_data.S88Obj.ProcedureLogic.Link_col[i];
			if( link.LinkType.key.startsWith("Parallel")){
				PFC_Diagram.model.addNodeData({ key: link.ID, isGroup: false, group: group_data.key, category:"parallel"});
			}
		}		
		
		// Add links
		// add parallel branches to nodeDataArray
		for(var i = 0; i < group_data.S88Obj.ProcedureLogic.Link_col.length; i++){
			var link = group_data.S88Obj.ProcedureLogic.Link_col[i];
			if( !link.LinkType.key.startsWith("Parallel")){
				PFC_Diagram.model.addLinkData({ from: link.FromID_col[0].FromIDValue, to: link.ToID_col[0].ToIDValue });
			}
		}			

		PFC_Diagram.commitTransaction("addGroupContents");
	}
  </script>
  <script>  
    class test{
		constructor(){
			this.x = 0;
			if (arguments.length) {arguments[0].call(this);}
		}
		static someFn(){
			this.x = 12.34;
		}
	}
	
	function zzz(x,y,z){
	}
	
	function quickTest(){generateSimpleRecipe()}
	
	function generateSimpleBatchInformation(){
		var simpleRecipe = new generateSimpleRecipe();
		var batchInformation = new BatchInformationType();
		batchInformation.MasterRecipe_col.push(simpleRecipe)
		return batchInformation;
	}
	
	function generateSimpleRecipe(){
		// make short "nicknames" to simplify namespace qualified syntax for commonly used methods
		RecipeProcedure = RecipeBuilder.RecipeProcedure;
		Parallel = RecipeBuilder.Parallel
		Declare = RecipeBuilder.Declare;
		Unit = RecipeBuilder.Unit;
		Operation = RecipeBuilder.Operation;

		var recipeBuilder = new 
		RecipeBuilder( "TestRecipe",
			RecipeProcedure( // create a recipe procedure.  Can be referenced by the default name "Procedure"
				ProcessParameter("InputScanCode", "ID", blankUUID4()),
				ProcessParameter("OutputScanCode", "ID", blankUUID4()),			
				ProcessParameter("InputVesselNum", "positiveInteger", 0),
				ProcessParameter("BioreactorNum", "positiveInteger", 0),								
				ProcessParameter("OutputVesselNum", "positiveInteger", 0),							
				ProcessParameter("Temperature", "float", 37.0),			
				Parallel( // create several Unit Procedures that run in parallel
					UnitProcedure( "Input", // Unit creates a Unit Procedure and binds it to corresponding step in parent Procedure
					),
					UnitProcedure( "Bioreactor", // Unit creates a Unit Procedure and binds it to corresponding step in parent Procedure
					),
					UnitProcedure( "Output", // Unit creates a Unit Procedure and binds it to corresponding step in parent Procedure
					)					
				)
			)
		);
		// return the Master Recipe that we generated
		return recipeBuilder.RecipeElement;
	}
  </script>  

    </head>
    <body >
        <font face="Arial">
			<h1>Biorealize Net Architecture Test Harness</h1>
			<div id="messages"></div>
			<button type="button" onclick='testTypedArray();'>testTypedArray</button>
			<button type="button" onclick='testInstantiations();'>testInstantiations</button>
			<button type="button" onclick='testEnumerationType();'>testEnumerationType</button>
			<button type="button" onclick='testCreateMasterRecipe();'>testCreateMasterRecipe</button>
			<button type="button" onclick='testparseBatchML();'>testparseBatchML</button>
			<button type="button" onclick='testControlRecipeFromMasterRecipe();'>testControlRecipeFromMasterRecipe</button>
			<button type="button" onclick='testGenerateBatchML();'>testGenerateBatchML</button>			
			<button type="button" onclick='testTreeView();'>testTreeView</button>						
			<button type="button" onclick='testSFCView();'>testSFCView</button>	
			<button type="button" onclick='testHierarchicalGrouping();'>testHierarchicalGrouping</button>								
			<button type="button" onclick='testPFCRendering();'>testPFCRendering</button>
			<button type="button" onclick='quickTest();'>quickTest</button>														
			 <hr/>
			<div id="status">unknown</div>
        </font>
		
		<div id="treeDiagramDiv" style="border: 1px solid black; width: 768px; height: 500px; display: none" ></div>
		<div id="SFC_Div" style="border: solid 1px black; width: 100%; height: 600px; display: none"></div>
  		<div id="testHierarchicalGroupingDiv" style="height:600px;width:100%;border:1px solid black; display: none"></div>
  		<div id="testPFCRenderingDiv" style="height:600px;width:100%;border:1px solid black; display: none"></div>		
    </body>



</html>
